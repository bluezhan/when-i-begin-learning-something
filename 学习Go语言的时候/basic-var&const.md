# Go 变量和常量（var、const）

接触过JavaScript都知道关于定义变量的方法。var\let\const。  

说回主题(～￣(OO)￣)ブ！！！  

## 变量(var)

声明变量格式：`var <name> <type>`
其中 var 是关键字（固定不变），name 是变量名，type 是类型。  

比如：`var name sting = "当我学习Go的时候"`

`var` 通常用于与初始化表达式类型不一致的局部变量、后面再赋值或初始值不重要的情况，否则可以使用更加简便的短变量声明。

在go语言中，任何类型在声明后没有赋值的情况下，都对应一个零值。

- 整形如int8、byte、int16、uint、uintprt等，默认值为0。
- 浮点类型如float32、float64，默认值为0。
- 布尔类型bool的默认值为false。
- 复数类型如complex64、complex128，默认值为0+0i。
- 字符串string的默认值为“”。
- 错误类型error的默认值为nil。
- 对于一些复合类型，如指针、切片、字典、通道、接口，默认值为nil。而数组的默认值要根据其数据类型来确定。例如：var a [4]int，其默认值为[0 0 0 0]。


局部变量

局部变量声明就必须使用，否则编译时会报错

全局变量

全局变量声明后可以不使用，编译时不会报错
全局变量首字母必须大写，否则从其他包中就无法访问到
由于所有语句必须在函数中，所以无法通过 := 声明全局变量，全局变量只能通过 var 进行声明


### 短变量声明

Go语法很简洁，没分号，很多地方也没括号；这是时候在rang或者循环条件里使用定义变量就麻烦了。
比如这样：
```
for var a = 0; a < 68; a ++{
    fmt.Println(a)
}  
```
按道理来说，Go解析语言可以做到这样的编译，不过这样的语法会很奇怪，考虑到这里的作用 < var;
使用使用短变量，是个不错做法。

所以弄了个替代写法，然后就有了短变量的写法。
name := "Bruce Jenn"

需要注意的是，简短模式（short variable declaration）有以下限制：
- 定义变量，同时显式初始化。
- 不能提供数据类型。
- 只能用在函数内部。

借助短变量声明操作符（：=），您只能声明仅具有块级作用域的局部变量。通常，局部变量在功能块内部声明。如果尝试使用short声明运算符声明全局变量，则会抛出错误消息。

使用短变量注意事项：

- 短变量声明方式只能用于函数内部局部变量，不能在包级别中使用。
- 短变量声明语句中至少要声明一个新的变量。
- 在不同的作用域(if,for,switch)，短变量声明语句会重新声明新的变量。

对于每次循环，key和val都是新的？？？

简短变量场景只能用于函数中，使用:=来声明和初始化全局变量是行不通的。

比如，像下面这样：

```
package sugar
import fmt
rule := "Short variable declarations" // syntax error: non-declaration statement outside function body
```

这里的编译错误提示syntax error: non-declaration statement outside function body，表示非声明语句不能出现在函数外部。可以理解成:= 实际上会拆分成两个语句，即声明和赋值。赋值语句不能出现在函数外部的。

我们知道使用:=一次可以声明多个变量，像下面这样：

field1, offset := nextField(str, 0)
上面代码定义了两个变量，并用函数返回值进行赋值。

如果这两个变量中的一个再次出现在:=左侧就会重新声明。像下面这样：

field1, offset := nextField(str, 0)
field2, offset := nextField(str, offset)
offset被重新声明。

重新声明并没有什么问题，它并没有引入新的变量，只是把变量的值改变了，但要明白，这是Go提供的一个语法糖。

当:=左侧存在新变量时（如field2），那么已声明的变量（如offset）则会被重新声明，不会有其他额外副作用。
当:=左侧没有新变量是不允许的，编译会提示no new variable on left side of :=。
我们所说的重新声明不会引入问题要满足一个前提，变量声明要在同一个作用域中出现。如果出现在不同的作用域，那很可能就创建了新的同名变量，同一函数不同作用域的同名变量往往不是预期做法，很容易引入缺陷。


变量作用域问题
几乎所有的工程师都了解变量作用域，但是由于:=使用过于频繁的话，还是有可能掉进陷阱里。

下面代码源自真实项目，但为了描述方便，也为了避免信息安全风险，简化如下：

func Redeclare() {
    field, err:= nextField()   // 1号err
 
    if field == 1{
        field, err:= nextField()     //　2号err
        newField, err := nextField() //  3号err
        ...
    }
    ...
}
注意上面声明的三个err变量。 2号err与1号err不属于同一个作用域，:=声明了新的变量，所以2号err与1号err属于两个变量。 2号err与3号err属于同一个作用域，:=重新声明了err但没创建新的变量，所以2号err与3号err是同一个变量。

如果误把2号err与1号err混淆，就很容易产生意想不到的错误。

短变量声明可能只出现在函数内部。在某些上下文中，例如“if”、“for”或“Switch”语句的初始化项，它们可以用于声明局部变量临时变量。

你可以想到var语句如const，type，和func，在包级别上，你必须指定要声明的语句类型。

嗯，这不是一个真正的速记，a, b := 12不会编译，var a,b = 12可以

位掩饰表达式

https://www.cnblogs.com/dbf-/p/12059706.html

